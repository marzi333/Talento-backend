from langchain.document_loaders import PyPDFLoader
from langchain.chains.question_answering import load_qa_chain
from langchain.document_loaders import JSONLoader
from langchain.docstore.document import Document
from langchain.prompts import PromptTemplate
from langchain.chains import SequentialChain, LLMChain


from sklearn.metrics.pairwise import cosine_similarity
import numpy as np
import json

def clean_and_parse_json_string(s):
    # Remove any unwanted substrings like "```JSON" and "```"
    cleaned_s = s.replace('```JSON', '').replace('```', '').replace('json','')
    
    # Convert escaped newlines to actual newlines
    cleaned_s = cleaned_s.replace('\\n', '\n')
    
    try:
        return json.loads(cleaned_s)
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON: {e}")
        return None
    
def get_detailed_information(llm,path):
    pdf_loader = PyPDFLoader(path)
    documents = pdf_loader.load()

    prompt = f"""Extract from the CV given, the following information of the user cv (max 50 words in total, and max 5 item per key): 'Experiences', 'Education','Skills'. The keys can only be these, without subkeys. Return them in a JSON format (making sure it is correctly formatted). If you do not find some information, just put 'Not known'."""
    chain = load_qa_chain(llm=llm, chain_type="stuff") #prompt=PROMPT)
    skills = chain.run(input_documents=documents, question=prompt)
    return skills


def get_main_information(llm,path):
    pdf_loader = PyPDFLoader(path)
    documents = pdf_loader.load()

    prompt = f"""Extract from the CV given, the following information of the user cv: 'Name','Email','Age','Nationality'. Return them in a JSON format (making sure it is correctly formatted). If you do not find some information, just put 'Not known'."""
    chain = load_qa_chain(llm=llm, chain_type="stuff") #prompt=PROMPT)
    skills = chain.run(input_documents=documents, question=prompt)
    return skills


def answer_to_autogeneratedcv(llm,answers):
    answers = json.loads(answers)

    answers = [Document(page_content=answers["A"]) for answers in answers]

    prompt = f"""Connect the given answers (summarise them as well) to one of the three field 'Experiences' , 'Education','Skills'. The keys can only be these, without subkeys. Return it in a JSON format with that three fields (making sure it is correctly formatted)."""
    chain = load_qa_chain(llm=llm, chain_type="stuff") #prompt=PROMPT)
    skills = chain.run(input_documents=answers, question=prompt)
    return skills
    

def get_experience_level(llm,path,answers):
    pdf_loader = PyPDFLoader(path)
    documents = pdf_loader.load()

    answers = json.loads(answers)

    answers = [answers["A"] for answers in answers]

    prompt = f"""Give a score from 0 to 5 on seniority basing yourself on the given person cv and their answers --{" ".join(answers)}--. Also provide a reason for your choice. Return it in a JSON format with keys "seniority_level" and "reason" (making sure it is correctly formatted)."""
    chain = load_qa_chain(llm=llm, chain_type="stuff") #prompt=PROMPT)
    skills = chain.run(input_documents=documents, question=prompt)
    return skills



def extract_skills_cv(llm,path,job_descr):
    print(path)

    pdf_loader = PyPDFLoader(path)
    documents = pdf_loader.load()

    #concatenate the documents in a string separated by \n

    cv = "\n".join([document.page_content for document in documents])

    synopsis_template = """Extract the main skills (max 10) from the following CV:

    CV: {cv}
    ==================
    Return the skills in a JSON format"""
    synopsis_prompt_template = PromptTemplate(input_variables=["cv"], template=synopsis_template)
    synopsis_chain = LLMChain(llm=llm, prompt=synopsis_prompt_template,output_key="cv_skills")


    template = """From the given skills, select only the one that are also present in the job description.

    Given skills: 
    {cv_skills}
    ==================

    Job description:
    {job_description}
    ==================
    The final skills must be a subset of the given initial skills. Return the final skills in a JSON format"""

    prompt_template = PromptTemplate(input_variables=["cv_skills","job_description"], template=template)
    review_chain = LLMChain(llm=llm, prompt=prompt_template,output_key="filtered_skills")

    overall_chain = SequentialChain(chains=[synopsis_chain, review_chain], input_variables=["cv", "job_description"], output_variables=["cv_skills", "filtered_skills"],verbose=True)
    review = overall_chain({"cv": cv, "job_description": job_descr})

    return review["filtered_skills"]
    

def extract_skills_job_descr(llm,job_descr):
    template = f"""Extract the main skills (max 10) from the following job description: ---{job_descr}---.Return them in a JSON format"""
    skills = llm(template)
    return skills

def generate_questions(llm,job_descr,cv_path):

    pdf_loader = PyPDFLoader(cv_path)
    documents = pdf_loader.load()

    prompt=f"""Question: Generate a set of deep dive questions for the interview based on the job description focus on assessing the candidate's strong hard skills and choose 5 best one. 
    Use the CV information about the candidate and ask a question about the job position if the description of it in the CV is missing.
    Write it in json format with keys "Q:". 

    Job description: --- {job_descr}   ---
    CV Information: --- {documents} ---

    Answer:
    """
    

    chain = load_qa_chain(llm=llm, chain_type="stuff") #prompt=PROMPT)
    print("Generating 2 :D")
    generated_questions = llm(prompt)

    generate_questions_cleaned = clean_and_parse_json_string(generated_questions)

    return generate_questions_cleaned



def cosine_similarity_sklearn(vec_a, vec_b):
    vec_a = np.array(vec_a).reshape(1, -1)
    vec_b = np.array(vec_b).reshape(1, -1)
    return cosine_similarity(vec_a, vec_b)[0][0]


def get_similarity(embeddings,job_descr_skills,cv_skills):

    # Parse skills
    job_skills = clean_and_parse_json_string(job_descr_skills)
    job_skills = job_skills["skills"]
    print(job_skills)

    cv_skills = clean_and_parse_json_string(cv_skills)
    cv_skills = cv_skills["skills"]
    print(cv_skills)

    # Skill Embedding
    job_skill_embeddings = embeddings.embed_documents(job_skills)
    cv_skill_embeddings = embeddings.embed_documents(cv_skills)

    # Step 3 and 4: Skill Comparison and Matching
    similarity_scores = []
    total_relevant_skills = []
    weight_neg = 0.5
    weight_pos = 0.2
    for i,job_skill_embedding in enumerate(job_skill_embeddings):
        relevant_skills = []

        index_most_similar_score = -1
        most_similar_score = -1
        for j,cv_skill_embedding in enumerate(cv_skill_embeddings):
            print(cv_skills[j])
            print(job_skills[i])
            similarity = cosine_similarity_sklearn(job_skill_embedding, cv_skill_embedding)
            print(similarity)
            if similarity > most_similar_score:
                most_similar_score = similarity
                index_most_similar_score = j
            
            if similarity > 0.7:
                    relevant_skills.append(cv_skills[j])

        if most_similar_score < 0.2:
                most_similar_score-=weight_neg

        most_similar_score += (len(relevant_skills)*weight_pos)
        if most_similar_score >= 1:
            most_similar_score = 1
        #extend total_relevant_skills with relevant_skills
        total_relevant_skills.extend(relevant_skills)
        similarity_scores.append(most_similar_score)

    average_similarity = sum(similarity_scores) / len(similarity_scores)
    print(f"The average similarity between the job description and CV  is {average_similarity}")

    return average_similarity, list(set(total_relevant_skills))






